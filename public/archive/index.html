 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5:4 Container, Fixed 16:9 Video, All Proportional</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #f3f4f7;
      overflow: hidden;
    }
    .centerer {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .main-container {
      height: 100vh;
      width: calc(100vh * 5 / 4);
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      overflow: hidden;
      min-width: 0;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }
    .video-wrapper {
      width: 100%;
      background: #000;
      border-radius: 8px 8px 0 0;
      overflow: hidden;
      position: relative;
      /* Height set in JS */
      min-width: 0;
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .video-wrapper video {
      width: 100%;
      height: 100%;
      object-fit: fill;
      display: block;
      background: #000;
      border-radius: 8px 8px 0 0;
    }
    .mic-indicator {
      position: absolute;
      top: 20px;
      right: 10px;
      background-color: #dc3545;
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-weight: bold;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      transition: background-color 0.3s ease;
      z-index: 10;
    }
    .mic-on { background-color: #28a745; }
    .content-box {
      width: 100%;
      /* Height set in JS */
      display: flex;
      flex-direction: column;
      align-items: stretch;
      box-sizing: border-box;
      gap: 0;
      min-width: 0;
      min-height: 0;
    }
    .roleplay-title,
    .controls,
    textarea,
    .status,
    .log {
      width: 100%;
      min-width: 0;
      box-sizing: border-box;
      margin: 0;
      padding: 0.3em;
      font-size: 1.8vh;
    }
    .roleplay-title { text-align: center; font-weight: bold; }
    .controls      { display: flex; gap: 1vw; align-items: center; justify-content: center; }
    textarea       { border: 1px solid #ccc; border-radius: 4px; resize: none; }
    .status        { text-align: center; font-weight: bold; color: #333; }
    .log           { background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; overflow-y: auto; }
    button         { padding: 0.3em 0.8em; border-radius: 4px; border: none; cursor: pointer; }
    button.start   { background-color: #28a745; color: #fff; }
    button.send    { background-color: #007bff; color: #fff; }
    button.end     { background-color: #dc3545; color: #fff; }
    button:disabled { background-color: #ccc; cursor: not-allowed; }
    /* Hide debug by default */
    #debugContainer { display: none; }
  </style>
</head>
<body>
  <div class="centerer">
    <div class="main-container">
      <div class="video-wrapper">
        <video id="avatarVideo" autoplay controls></video>
        <div class="mic-indicator" id="micIndicator">üîá Mic Off</div>
      </div>
      <div class="content-box">
        <h2 class="roleplay-title">RoleplayLogic</h2>
        <div class="controls">
          <button id="startBtn" class="start">Initialize Roleplay</button>
          <button id="endBtn" class="end" disabled>End Session</button>
          <button id="pauseMicBtn" class="send" disabled>Pause Mic</button>
        </div>
        <textarea id="messageInput" placeholder="Type your message here..."></textarea>
        <div class="status" id="status">Idle</div>
        <div class="log" id="logBox"></div>
      </div>
    </div>
  </div>
  <!-- Debug/retell section hidden by default -->
  <div class="container" id="debugContainer">
    <h2>üó£Ô∏è Degug Logs</h2>
    <textarea id="retell-message" placeholder="Type your message for Retell..."></textarea>
    <div>
      <button id="retellStartBtn" class="start">Start Retell Session</button>
      <button id="retellSendBtn" class="send" disabled>Send Message</button>
      <button id="retellEndBtn" class="end" disabled>End Retell Session</button>
    </div>
    <div class="log retell-log" id="retellLogBox"></div>
  </div>
  
  <script>
    function layoutProportional() {
      // Get containers
      const container = document.querySelector('.main-container');
      const videoWrapper = container.querySelector('.video-wrapper');
      const contentBox = container.querySelector('.content-box');

      // Container sizes
      const contHeight = container.offsetHeight;
      const contWidth  = container.offsetWidth;

      // Video: height = container width * 9/16 (for 16:9 ratio)
      let vidHeight = contWidth * 9 / 16;
      if (vidHeight > contHeight) vidHeight = contHeight;

      // Other UI elements: get remaining height
      const otherHeight = contHeight - vidHeight;

      // Set heights
      videoWrapper.style.height = vidHeight + 'px';
      contentBox.style.height = otherHeight + 'px';
    }
    window.addEventListener('resize', layoutProportional);
    window.addEventListener('load', layoutProportional);
  </script>
  <!-- Your full app JS goes here, unchanged -->
  <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
  <!-- (Move your big JS code here as in your original file; the above only handles layout/scaling) -->
</body>  
   
   
   
   
   
   
  <script>
    // Heygen Variables
    let sessionUrl, accessToken, room, mediaStream = new MediaStream();
    const videoEl = document.getElementById('avatarVideo');
    const logBox = document.getElementById('logBox');
    const statusEl = document.getElementById('status');
	let micPaused = false;
	
	videoEl.disablePictureInPicture = true;
	
	const DEBUG = false

	if (!DEBUG) {
		const debugContainer = document.getElementById('debugContainer');
		if (debugContainer) {
			debugContainer.style.display = 'none';
			console.log('üîí DEBUG off: debugContainer hidden');
		}
	}

    function log(msg) {
      const t = new Date().toLocaleTimeString();
      logBox.textContent += `[${t}] ${msg}\n`;
      logBox.scrollTop = logBox.scrollHeight;
    }

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    async function startSession() {
      setStatus("Starting Roleplay session...");
      document.getElementById('startBtn').disabled = true;
      try {
        retellLogMsg("‚û°Ô∏è Requesting backend to start Roleplay session...");
        const res = await fetch("/api/avatar/start", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            avatarName: "June_HR_public",
            voiceId: "131a436c47064f708210df6628ef8f32"
          })
        });
        const data = await res.json();
        if (!data.success) throw new Error(data.error);

        sessionUrl = data.session.url;
        accessToken = data.session.access_token;

        retellLogMsg("üé• Preparing LiveKit connection...");
        room = new LivekitClient.Room({ adaptiveStream: true });
        room.on(LivekitClient.RoomEvent.TrackSubscribed, (track) => {
          retellLogMsg("üìπ Track subscribed");
          mediaStream.addTrack(track.mediaStreamTrack);
          videoEl.srcObject = mediaStream;
        });

        await room.prepareConnection(sessionUrl, accessToken);
        retellLogMsg("‚úÖ prepareConnection successful");

        const streamRes = await fetch("/api/avatar/start-stream", { method: "POST" });
        const streamData = await streamRes.json();
        if (!streamData.success) throw new Error("Failed to start Avatar stream");

        await room.connect(sessionUrl, accessToken);
        retellLogMsg("‚úÖ LiveKit connected");

        setStatus("Roleplay session ready");
        document.getElementById('endBtn').disabled = false;
		autoStartRetell();
		document.getElementById('pauseMicBtn').disabled = false;
      } catch (err) {
        console.error("‚ùå Failed to start Avatar:", err);
        retellLogMsg(`‚ùå Failed: ${err.message}`);
        setStatus(`Failed: ${err.message}`);
        document.getElementById('startBtn').disabled = false;
      }
    }
	
	async function autoStartRetell() {
		retellLogMsg("‚û°Ô∏è Auto-starting Retell session...");
		if (!micUnlocked) {
			micUnlocked = true; // Unlock mic on first Retell Start
			initSpeechRecognition();
		}
		try {
			const res = await fetch("/api/retell/start", { method: "POST" });
			const data = await res.json();
			if (!data.success) throw new Error(data.error);
			retellActive = true;
			document.getElementById('retellStartBtn').disabled = true;
			document.getElementById('retellSendBtn').disabled = false;
			document.getElementById('retellEndBtn').disabled = false;
			retellLogMsg("üü¢ Retell session auto-started.");
			startVoiceRecognition();
		} catch (err) {
			console.error('‚ùå Auto-start Retell failed:', err);
			retellLogMsg(`‚ùå Error auto-starting Retell: ${err.message}`);
		}
	}

    async function sendMessage() {
      const text = document.getElementById("messageInput").value.trim();
      if (!text) return setStatus("Please enter a message");
      setStatus("Sending to Avatar...");
      try {
        const res = await fetch("/api/avatar/talk", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text })
        });
        const data = await res.json();
        if (!data.success) throw new Error(data.error);
        setStatus("Avatar is speaking...");
      } catch (err) {
        console.error("‚ùå Failed to send message:", err);
        setStatus(`Failed: ${err.message}`);
      }
    }

	async function endSession() {
		setStatus("Ending Heygen session...");
		try {
			const res = await fetch("/api/avatar/end", { method: "POST" });
			const data = await res.json();
			if (!data.success) throw new Error(data.error);
			if (room) room.disconnect();
			videoEl.srcObject = null;
			mediaStream = new MediaStream();
			setStatus("Heygen session ended");

			// üî• Auto-end Retell too
			await fetch("/api/retell/end", { method: "POST" });
			retellActive = false;
			stopVoiceRecognition();
			retellLogMsg("üî¥ Retell session auto-ended with Heygen.");
			document.getElementById('retellStartBtn').disabled = false;
			document.getElementById('retellSendBtn').disabled = true;
			document.getElementById('retellEndBtn').disabled = true;
			document.getElementById('pauseMicBtn').disabled = true;

		} catch (err) {
			console.error("‚ùå Failed to end session:", err);
			setStatus(`Failed: ${err.message}`);
		} finally {
			document.getElementById('startBtn').disabled = false;
			document.getElementById('sendBtn').disabled = true;
			document.getElementById('endBtn').disabled = true;
		}
	}

    document.getElementById('startBtn').addEventListener("click", startSession);
    document.getElementById('endBtn').addEventListener("click", endSession);

    // Retell & Voice (fully independent from Heygen)
    let recognition, micUnlocked = false, retellActive = false, isListening = false, isAvatarSpeaking = false;
    const micIndicator = document.getElementById('micIndicator');
    const retellLog = document.getElementById("retellLogBox");

    function updateMicIndicator(state) {
		console.log('‚ùå in switch CASE');
		switch (state) {
			case 'on':
				micIndicator.textContent = 'üé§ Mic On';
				micIndicator.classList.add('mic-on');
				break;
			case 'paused':
				console.log('‚ùå made it to paused!!!!!')
				micIndicator.textContent = '‚è∏Ô∏è Mic Paused';
				micIndicator.classList.remove('mic-on');
				break;
			case 'off':
			default:
				if (micPaused) return;
				micIndicator.textContent = 'üîá Mic Off';
				micIndicator.classList.remove('mic-on');
				break;
		}
	}

    function initSpeechRecognition() {
      if (!('webkitSpeechRecognition' in window)) {
        alert('Speech recognition not supported in this browser');
        return;
      }
      recognition = new webkitSpeechRecognition();
      recognition.lang = 'en-US';
      recognition.continuous = false;
      recognition.interimResults = false;

      recognition.onstart = () => {
        isListening = true;
        updateMicIndicator('on');
		console.log('‚ùåüé§ updateMicIndicator(true1)');
        console.log('üé§ Mic is now ON');
      };

      recognition.onresult = async (event) => {
        const transcript = event.results[0][0].transcript.trim();
        console.log('üìù Heard:', transcript);
        stopVoiceRecognition();
		isAvatarSpeaking = true;  // This is a bug if its not set to faulse if the avatar is not started.  Its here because we need to not satrt the mic if the onend timer executes between here and heygen avatart call success
		console.log('‚ùå stopVoiceRecognition(1)');
		log(`üßë‚Äçü¶± Salesperson: ${transcript}\n`);
        await sendToRetell(transcript);
      };

      recognition.onerror = (event) => {
        console.error('‚ùå Mic error:', event.error);
        stopVoiceRecognition();
		console.log('‚ùå stopVoiceRecognition(2)');
      };

      recognition.onend = () => {
        isListening = false;
        updateMicIndicator('off');
		console.log('‚ùåüé§ updateMicIndicator(false2)');
        if (retellActive && micUnlocked && !isAvatarSpeaking) {
          console.log('üîÑ mic off...');
          setTimeout(() => {
				if (!micPaused) {
					startVoiceRecognition();
				} else {
					console.log('‚è∏Ô∏è Mic paused: not restarting');
				}
			}, 500);
		  console.log('‚ùå startVoiceRecognition(500)');
        }
      };
    }

    function startVoiceRecognition() {
      if (!micUnlocked) return;
	  if (micPaused) return;
      if (!recognition) initSpeechRecognition();
      if (!isListening && retellActive && !isAvatarSpeaking) {
        console.log('‚ñ∂Ô∏è Starting mic...');
        try {
          recognition.start();
        } catch (e) {
          console.error('‚ö†Ô∏è Mic start failed:', e.message);
        }
      }
    }

    function stopVoiceRecognition() {
      if (recognition && isListening) {
        recognition.stop();
      }
      isListening = false;
      updateMicIndicator('off');
	  console.log('‚ùåüé§ updateMicIndicator(false3)');
    }

    async function sendToRetell(text) {
      try {
        const res = await fetch('/api/retell/talk', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text })
        });
			
		const data = await res.json();

        if (!data.success) throw new Error(data.error);
        log(`ü§ñ AI Prospect: ${data.agentReply}`);
		log(`üïë Speaking for: ${(data.duration_ms / 1000).toFixed(1)}'s\n`);

        isAvatarSpeaking = true;
        console.log(`üïë Avatar speaking for ${data.duration_ms} ms`);
        updateMicIndicator('off');
		console.log('‚ùåüé§ updateMicIndicator(false4)');

		setTimeout(() => {
          isAvatarSpeaking = false;
          startVoiceRecognition();
		  console.log('‚ùå startVoiceRecognition(1)');
        }, (data.duration_ms+100));



      } catch (err) {
        console.error('‚ùå Error sending to Retell:', err);
        isAvatarSpeaking = false;
        startVoiceRecognition();
		console.log('‚ùå startVoiceRecognition(2)');
      }
    }

    function retellLogMsg(msg) {
      const t = new Date().toLocaleTimeString();
      retellLog.textContent += `[${t}] ${msg}\n`;
      retellLog.scrollTop = retellLog.scrollHeight;
    }

    document.getElementById('retellStartBtn').addEventListener('click', async () => {
      if (!micUnlocked) {
        micUnlocked = true; // Unlock mic only on first Retell Start
        initSpeechRecognition();
      }
      retellLogMsg("‚û°Ô∏è Starting Retell session...");
      try {
        const res = await fetch("/api/retell/start", { method: "POST" });
        const data = await res.json();
        if (!data.success) throw new Error(data.error);
        retellActive = true;
        document.getElementById('retellStartBtn').disabled = true;
        document.getElementById('retellSendBtn').disabled = false;
        document.getElementById('retellEndBtn').disabled = false;
        retellLogMsg("üü¢ Retell session started.");
        startVoiceRecognition();
		console.log('‚ùå startVoiceRecognition(3)');
      } catch (err) {
        console.error(err);
        retellLogMsg(`‚ùå Error starting Retell session: ${err.message}`);
        stopVoiceRecognition();
		console.log('‚ùå stopVoiceRecognition(3)');
      }
    });

    document.getElementById('retellEndBtn').addEventListener('click', async () => {
      retellLogMsg("üõë Ending Retell session...");
      try {
        await fetch("/api/retell/end", { method: "POST" });
        retellActive = false;
        stopVoiceRecognition();
		console.log('‚ùå stopVoiceRecognition(4)');
        document.getElementById('retellStartBtn').disabled = false;
        document.getElementById('retellSendBtn').disabled = true;
        document.getElementById('retellEndBtn').disabled = true;
        retellLogMsg("üî¥ Retell session ended.");
      } catch (err) {
        console.error(err);
        retellLogMsg(`‚ùå Error ending Retell session: ${err.message}`);
      }
    });
	
	document.getElementById('pauseMicBtn').addEventListener('click', () => {
		const pauseBtn = document.getElementById('pauseMicBtn');
		const micIndicator1 = document.getElementById('micIndicator');
		console.log('In pauseMicBtn');
		console.log(`isAvatarSpeaking = ${isAvatarSpeaking}`);
		console.log(`micPaused = ${micPaused}`);
		if (micPaused) {
			if (!isAvatarSpeaking) {
				console.log('üé§ Resuming mic...');
				micPaused = false;
				pauseBtn.textContent = 'Pause Mic';
				micIndicator1.textContent = 'üé§ Mic On';
				startVoiceRecognition();
			} else {
				micPaused = false;
				pauseBtn.textContent = 'Pause Mic';
				micIndicator1.textContent = 'üîá Mic Off';
			}

		} else {
			console.log('‚è∏Ô∏è Pausing mic...');
			micPaused = true;
			pauseBtn.textContent = 'Resume Mic';
			stopVoiceRecognition();
			updateMicIndicator('paused');
		}
	});
	
	
  </script>
</body>
</html>
